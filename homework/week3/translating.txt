Translate between the C and MIPS code. You may want to use the MIPS Green Sheet as a reference. In all of
the C examples, we show you how the different variables map to registers – you don’t have to worry about the
stack or any memory-related issues.

 ---------------------------------------------------------------------------------------------------------------------------
|															|																|
|	C														|	MIPS														|	
|															|																|
 ---------------------------------------------------------------------------------------------------------------------------
|															|																|
|	// $s0 -> a, $s1 -> b									|	addiu $s0, $0, 4											|
|	// $s2 -> c, $s3 -> z									|	addiu $s1, $0, 5											|
|	int a = 4, b = 5, c = 6, z;								|	addiu $s2, $0, 6											|
|	z = a + b + c + 10;										|	addu $s3, $s0, $s1											|
|															|	addu $s3, $s3, $s2											|
|															|	addiu $s3, $s3, 10											|
|															|																|
 ---------------------------------------------------------------------------------------------------------------------------
|															|																|
|	// $s0 -> int * p = intArr;								|	sw $0, 0($s0)												|
|	// $s1 -> a;											|	addiu $s1, $0, 2											|
|	*p = 0;													|	sw $s1, 4($s0)												|
|	int a = 2;												|	sll $t0, $s1, 2												|
|	p[1] = p[a] = a;										|	add $t0, $s0, $t0											|	|															|	sw $s1, 0($t0)												|
|															|																|	
 ---------------------------------------------------------------------------------------------------------------------------
|															|																|
|	// $s0 -> a, $s1 -> b									|		addiu $s0, $0, 5										|
|	int a = 5, b = 10;										|		addiu $s1, $0, 10										|
|	if(a + a == b) {										|		addu $t0, $s0, $s0										|
|		a = 0;												|		bne $t0, $s1, L1										|
|	} else {												|		xor $s0, $0, $0	
|															|		j L2
|		b = a - 1;											|	L1:	addiu $s1, $s0, -1										|
|	}														|	L2:															|
|															|																|
 ---------------------------------------------------------------------------------------------------------------------------
|															|																|
|	// $s0 -> a, $s1 -> b									|		addiu $s0, $0, 0										|
|	int a = 0, b = 1;										|		addiu $s1, $0, 1										|
|	while (a != 30) {										|		addiu $t0, $0, 30										|
|		b = b + b;											|	loop:														|
|		a++;												|		beq $s0, $t0, exit										|
|	}														|		addu $s1, $s1, $s1										|
|															|		addiu $s0, $s0, 1										|
|															|		j loop													|
|															|	exit:														|
|															|																|
 ---------------------------------------------------------------------------------------------------------------------------
|															|																|
|	// $a0 -> n, $v0 -> sum									|		xor $v0, $0, $0											|
|	int sum;												|	loop:														|
|	for(sum=0;n>0;sum+=n--);								|		blez $a0, exit											|
|															|		addu $v0, $v0, $a0										|
|															|		addiu $a0, $a0, -1										|
|															|		j loop													|
|															|	exit:														|
|															|																|
 ---------------------------------------------------------------------------------------------------------------------------				
